# -*- coding: utf-8 -*-
"""Controlled Queueing Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17FAqHV4kHjLhRd2n1BT4j7wCV7VLTkFE

Computational Project: Controlled Queueing Model
"""

import numpy as np

"""Parameter Space"""

# Running Price
a = np.array([3,7])
# Control Cost
c = np.array([5,9])
# Penalty Cost
C = np.array([25,12])
# Arrival Rate
Lambda = np.array([0.4,0.6])
# Service Rate
mu = np.array([0.2,0.8])
# Discounted Rate
rho = 0.9
# Buffer Capacity
B = 6

"""Jumping Directions"""

dirc = np.array([[1,0], [0,1], [-1,0], [0,-1]])

def cost(x, u):
  return np.inner(a, x) + c[u - 1] + (x[0] + x[1] == B) * np.inner(Lambda, C)
def rate(x, y, u):
  diff = y - x
  if (np.array_equal(diff, dirc[0])):
    return q[0]
  if (np.array_equal(diff, dirc[1])):
    return q[1]
  if (np.array_equal(diff, dirc[2]) and x[0] > 0 and u == 1):
    return s[0]
  if (np.array_equal(diff, dirc[3]) and x[1] > 0 and u == 2):
    return s[1]
  return 0
def rate_tot(x, u):
  if ((x[0] == 0 and u == 1) or (x[1] == 0 and u == 2)):
    return Lambda[0] + Lambda[1]
  return Lambda[0] + Lambda[1] + mu[u - 1]
def trans(x, y, u):
  return rate(x, y, u) / rate_tot(x, u)
def cost_eff(x, u):
  return cost(x, u) / (rho + rate_tot(x, u))
def disc_eff(x, u):
  return rate_tot(x, u) / (rho + rate_tot(x, u))

"""Initialization"""

V = np.zeros((B + 1, B + 1))
pi = np.full((B + 1, B + 1), 0)
prec = 0.001
def value(V, x, u):
  sum = 0
  for k in range(4):
    y = x + dirc[k]
    if (y[0] >= 0 and y[0] <= B and y[1] >= 0 and y[1] <= B):
       sum += trans(x, y, u) * V[y[0]][y[1]]
  return cost_eff(x, u) + sum * disc_eff(x, u)

"""Iteraction in Value Space

Recursion
"""

diff = 1
count = 0
while (diff > prec):
  count += 1
  V_pre = np.copy(V)
  for i in range(B + 1):
    for j in range(B - i + 1):
      x = np.array([i, j])
      values = [value(V, x, 1), value(V, x, 2)]
      V[i][j] = np.min(values)
      pi[i][j] = np.argmin(values) + 1
  diff = np.linalg.norm(V - V_pre)

print(V)
print(pi)
print(count)

"""Iteraction in Policy Space

Recursion
"""

def iter(V, pi):
  diff = 1
  while (diff > prec):
    V_pre = np.copy(V)
    for i in range(B + 1):
      for j in range(B - i + 1):
        x = np.array([i, j])
        V[i][j] = value(V, x, pi[i][j])
    diff = np.linalg.norm(V - V_pre)
  return V

diff = 1
count = 0
while (diff > prec):
  count += 1
  V_pre = np.copy(V)
  for i in range(B + 1):
      for j in range(B - i + 1):
        x = np.array([i, j])
        values = [value(V, x, 1), value(V, x, 2)]
        pi[i][j] = np.argmin(values) + 1
  for i in range(B + 1):
      for j in range(B - i + 1):
        V = iter(V, pi)
  diff = np.linalg.norm(V - V_pre)

print(V)
print(pi)
print(count)

